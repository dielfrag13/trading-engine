diff --git a/CMakeLists.txt b/CMakeLists.txt
index b192033..55a2fe9 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -44,6 +44,7 @@ add_subdirectory(src/engine)
 add_subdirectory(src/plugins)
 add_subdirectory(src/support)
 add_subdirectory(src/adapters)
+add_subdirectory(src/brokers)
 
 # Strategy & Broker plugins (optional: only if you want to build them here)
 # add_subdirectory(strategies/MovingAverage)
diff --git a/README.md b/README.md
index 3b2b0ab..0a35568 100644
--- a/README.md
+++ b/README.md
@@ -80,7 +80,7 @@ ctest --output-on-failure
 ```
 
 
-High-level ASCII representation
+High-level representation
 
 ```mermaid
 flowchart LR
diff --git a/build.sh b/build.sh
index 7a200c8..f73b573 100755
--- a/build.sh
+++ b/build.sh
@@ -7,7 +7,7 @@ else
 	cmake .. -DCMAKE_BUILD_TYPE=Debug
 
 fi
-cmake --build .
+cmake --build . -- -j$(nproc)
 
 # quick reference example -- to add debug statements in code:
 #ifdef ENG_DEBUG
diff --git a/include/brokers/NullBroker.hpp b/include/brokers/NullBroker.hpp
index 54f5390..cd5520f 100644
--- a/include/brokers/NullBroker.hpp
+++ b/include/brokers/NullBroker.hpp
@@ -2,30 +2,34 @@
 #include "engine/IBroker.hpp"
 #include <functional>
 #include <iostream>
+#include <mutex>
 
 namespace broker {
 
 class NullBroker : public eng::IBroker {
 public:
-    void place_order(const eng::Order& order) override {
-        std::cout << "[NullBroker] place_order: " << order.symbol
-                  << " qty=" << order.qty
-                  << " side=" << (order.side == eng::Order::Side::Buy ? "BUY" : "SELL")
-                  << std::endl;
-        // No-op fill simulation
-    }
+    explicit NullBroker(double initial_balance = 1'000'000.0);
+    ~NullBroker() override;
 
-    double get_balance() override { return 1'000'000.0; }
+    // TODO: may be able to get rid of place_order as we will always use market/limit explicitly
+    void place_order(const eng::Order& order) override;
+    void place_market_order(const eng::Order& order) override;
+    void place_limit_order(const eng::Order& order, double limit_price) override;
 
-    eng::PriceData get_current_price(const std::string& symbol) override {
-        return eng::PriceData{symbol, 100.0};
-    }
+    double get_balance() override;
 
+    eng::PriceData get_current_price(const std::string& symbol) override;
+
+    /*
     void subscribe_to_ticks(const std::string& symbol,
-                            std::function<void(const eng::PriceData&)> cb) override {
-        // For demo, just immediately invoke one tick
-        cb(eng::PriceData{symbol, 90.0});  // triggers a BUY given threshold=100
-    }
+                            std::function<void(const eng::PriceData&)> cb) override;
+    */
+
+private:
+    double balance_;
+    std::mutex mutex_;
 };
 
+
+
 }
\ No newline at end of file
diff --git a/include/engine/IBroker.hpp b/include/engine/IBroker.hpp
index 791530c..3a61197 100644
--- a/include/engine/IBroker.hpp
+++ b/include/engine/IBroker.hpp
@@ -11,10 +11,25 @@ namespace eng {
 class IBroker {
 public:
     virtual void place_order(const Order&) = 0;
+
+    // New explicit API separating market and limit orders
+    // Market order: execute immediately at current market price
+    virtual void place_market_order(const Order& order) {
+        // default delegates to place_order for implementations that only support a single method
+        place_order(order);
+    }
+
+    // Limit order: specify a limit price at which to execute
+    virtual void place_limit_order(const Order& order, double /*limit_price*/) {
+        // default implementation delegates to place_order; brokers that support limits should override
+        place_order(order);
+    }
     virtual double get_balance() = 0;
     virtual PriceData get_current_price(const std::string& symbol) = 0;
+    /*
     virtual void subscribe_to_ticks(const std::string& symbol,
                                     std::function<void(const PriceData&)> cb) = 0;
+    */
 
     virtual ~IBroker() = default;
 };
diff --git a/include/engine/IMarketData.hpp b/include/engine/IMarketData.hpp
index 3e59720..5d0f58a 100644
--- a/include/engine/IMarketData.hpp
+++ b/include/engine/IMarketData.hpp
@@ -25,6 +25,11 @@ public:
         const std::vector<std::string>& symbols,
         std::function<void(const TradePrint&)> on_trade) = 0;
 
+    // Optional lifecycle control for live adapters. Default no-op so existing
+    // implementations do not need to change immediately.
+    virtual void start(int /*seconds*/) { }
+    virtual void stop() { }
+
     // Historical/backfill (e.g., for warm-up / indicators / backtest)
     
     virtual std::vector<Candle> get_hist_candles(
diff --git a/include/engine/ProviderMarketData.hpp b/include/engine/ProviderMarketData.hpp
index 4d52ae7..c2d70e2 100644
--- a/include/engine/ProviderMarketData.hpp
+++ b/include/engine/ProviderMarketData.hpp
@@ -38,6 +38,22 @@ void subscribe_ticks(const std::vector<std::string>& syms,
     }
 
 }
+
+// Start all attached feeds for `seconds` seconds (feeds implement their own
+// behavior for lifecycle). This allows the provider to control when child
+// adapters emit ticks.
+void start_all(int seconds = 30) {
+  for (auto& f : feeds_) {
+    if (f) f->start(seconds);
+  }
+}
+
+// Stop all attached feeds and wait for them to terminate if they implement stop.
+void stop_all() {
+  for (auto& f : feeds_) {
+    if (f) f->stop();
+  }
+}
 private:
   std::vector<std::unique_ptr<eng::IMarketData>> feeds_;
   // symbol map, best-bid/ask chooser, failover policy, etc.
diff --git a/src/adapters/BrokerMarketData.cpp b/src/adapters/BrokerMarketData.cpp
index d603243..779f008 100644
--- a/src/adapters/BrokerMarketData.cpp
+++ b/src/adapters/BrokerMarketData.cpp
@@ -1,6 +1,8 @@
 #include "adapters/BrokerMarketData.hpp"
 #include "engine/Types.hpp"  // for PriceData (your existing type)
 #include <iostream>
+#include <random>
+#include <cmath>
 
 
 namespace adapter {
@@ -20,16 +22,25 @@ void BrokerMarketData::stop() {
     if (th_.joinable()) th_.join();
 }
 
-void BrokerMarketData::start(int seconds = 10) {
-    std::cout << "[BrokerMarketData] starting demo thread\n";
+// Emit ticks for `seconds` seconds on a background thread.
+// Prices start at 600.00 and change by a random decimal in [-1.0, +2.0]
+// each second, rounded to the nearest cent.
+void BrokerMarketData::start(int seconds = 30) {
+    std::cout << "[BrokerMarketData] starting demo thread (" << seconds << "s)\n";
     if (running_.exchange(true)) return;
-        th_ = std::thread([this, seconds] {
+
+    th_ = std::thread([this, seconds] {
         using namespace std::chrono_literals;
-        double px = 10000.0;
-        auto start = std::chrono::steady_clock::now();
+        // RNG for per-tick delta
+        std::random_device rd;
+        std::mt19937 gen(rd());
+        std::uniform_real_distribution<double> dist(-1.0, 2.0);
+
+        double px = 600.00; // starting price
+        auto start_tp = std::chrono::steady_clock::now();
 
-        while (running_) {
-            if (std::chrono::steady_clock::now() - start > std::chrono::seconds(seconds)) break;
+        while (running_.load()) {
+            if (std::chrono::steady_clock::now() - start_tp > std::chrono::seconds(seconds)) break;
 
             std::vector<std::string> syms;
             std::function<void(const eng::Tick&)> cb;
@@ -40,18 +51,23 @@ void BrokerMarketData::start(int seconds = 10) {
             }
 
             if (cb && !syms.empty()) {
+                // compute new price (random delta in [-1,2], round to cents)
+                double delta = dist(gen);
+                double new_px = std::round((px + delta) * 100.0) / 100.0;
+                px = new_px;
+
                 auto now_tp = std::chrono::system_clock::now();
                 for (const auto& s : syms) {
                     eng::Tick t{ s, px, now_tp };
-                    std::cout << "[BrokerMarketData thread] emitting a tick\n";
+                    std::cout << "[BrokerMarketData thread] emitting tick " << s << " @ " << px << '\n';
                     cb(t);
                 }
             }
 
-            px += 5.0;
             std::this_thread::sleep_for(1s);
         }
-        running_ = false;
+
+        running_.store(false);
     });
 }
 
diff --git a/src/brokers/CMakeLists.txt b/src/brokers/CMakeLists.txt
new file mode 100644
index 0000000..bc480bb
--- /dev/null
+++ b/src/brokers/CMakeLists.txt
@@ -0,0 +1,27 @@
+add_library(brokers
+  NullBroker.cpp
+)
+
+target_include_directories(brokers PUBLIC ${PROJECT_SOURCE_DIR}/include)
+target_link_libraries(brokers
+  PUBLIC
+    engine
+    support
+    Threads::Threads
+)
+
+if(TARGET pluginloader)
+  # If pluginloader exists, let it know about brokers (optional)
+  target_link_libraries(pluginloader PUBLIC brokers)
+endif()
+
+# Small test executable to exercise the NullBroker in-tree
+add_executable(test_nullbroker
+  test_nullbroker.cpp
+)
+target_link_libraries(test_nullbroker
+  PRIVATE
+    brokers
+    Threads::Threads
+)
+target_include_directories(test_nullbroker PRIVATE ${PROJECT_SOURCE_DIR}/include)
diff --git a/src/brokers/NullBroker.cpp b/src/brokers/NullBroker.cpp
new file mode 100644
index 0000000..bbbe9dc
--- /dev/null
+++ b/src/brokers/NullBroker.cpp
@@ -0,0 +1,91 @@
+#include "brokers/NullBroker.hpp"
+#include "engine/Types.hpp"
+#include <unordered_map>
+#include <vector>
+#include <chrono>
+
+namespace broker {
+
+NullBroker::NullBroker(double initial_balance)
+    : balance_(initial_balance) {}
+
+NullBroker::~NullBroker() = default;
+
+void NullBroker::place_order(const eng::Order& order) {
+    // default place_order will behave like a market order for now
+    place_market_order(order);
+}
+
+void NullBroker::place_market_order(const eng::Order& order) {
+    std::lock_guard<std::mutex> lk(mutex_);
+    // simple price model: query current price
+    auto pd = get_current_price(order.symbol);
+    double fill_price = pd.last;
+    double value = fill_price * order.qty;
+    if (order.side == eng::Order::Side::Buy) {
+        balance_ -= value;
+        std::cout << "NullBroker: Bought " << order.qty << " of " << order.symbol
+                  << " @ " << fill_price << " -> balance=" << balance_ << '\n';
+    } else {
+        balance_ += value;
+        std::cout << "NullBroker: Sold " << order.qty << " of " << order.symbol
+                  << " @ " << fill_price << " -> balance=" << balance_ << '\n';
+    }
+}
+
+void NullBroker::place_limit_order(const eng::Order& order, double limit_price) {
+    std::lock_guard<std::mutex> lk(mutex_);
+    auto pd = get_current_price(order.symbol);
+    double market = pd.last;
+    bool execute = false;
+    if (order.side == eng::Order::Side::Buy) {
+        // buy limit: execute if market price <= limit_price
+        execute = market <= limit_price;
+    } else {
+        // sell limit: execute if market price >= limit_price
+        execute = market >= limit_price;
+    }
+
+    if (execute) {
+        double value = market * order.qty;
+        if (order.side == eng::Order::Side::Buy) {
+            balance_ -= value;
+        } else {
+            balance_ += value;
+        }
+        std::cout << "NullBroker: Limit executed for " << order.symbol << " @ " << market
+                  << " (limit=" << limit_price << ") -> balance=" << balance_ << '\n';
+    } else {
+        std::cout << "NullBroker: Limit order for " << order.symbol << " @ " << limit_price
+                  << " not executed (market=" << market << ")\n";
+    }
+}
+
+double NullBroker::get_balance() {
+    std::lock_guard<std::mutex> lk(mutex_);
+    return balance_;
+}
+
+eng::PriceData NullBroker::get_current_price(const std::string& symbol) {
+    // Simple deterministic price model for testing; could be extended to random or fed prices
+    eng::PriceData pd;
+    pd.symbol = symbol;
+    pd.last = 100.0; // fixed price for now
+    return pd;
+}
+
+
+// Open design question -- do we need a broker to subscribe to ticks?
+// Or will the strategy plugins handle that? Currently, I don't see a reason
+// to have brokers manage tick subscriptions.
+/*
+void NullBroker::subscribe_to_ticks(const std::string& symbol,
+                                    std::function<void(const eng::PriceData&)> cb) {
+    // For the null broker we don't produce live ticks; acknowledge subscription
+    std::cout << "NullBroker: subscription registered for " << symbol << '\n';
+    (void)cb;
+}
+//*/
+
+
+} // namespace broker
diff --git a/src/brokers/test_nullbroker.cpp b/src/brokers/test_nullbroker.cpp
new file mode 100644
index 0000000..f636ffa
--- /dev/null
+++ b/src/brokers/test_nullbroker.cpp
@@ -0,0 +1,22 @@
+#include "brokers/NullBroker.hpp"
+#include "engine/Types.hpp"
+#include <iostream>
+
+int main() {
+    broker::NullBroker nb(100000.0);
+
+    eng::Order buy;
+    buy.symbol = "TEST";
+    buy.qty = 10;
+    buy.side = eng::Order::Side::Buy;
+
+    std::cout << "Initial balance: " << nb.get_balance() << "\n";
+    nb.place_market_order(buy);
+    std::cout << "After buy balance: " << nb.get_balance() << "\n";
+
+    eng::Order sell = buy; sell.side = eng::Order::Side::Sell;
+    nb.place_limit_order(sell, 90.0); // market=100 => should execute
+    std::cout << "After sell limit balance: " << nb.get_balance() << "\n";
+
+    return 0;
+}
diff --git a/src/engine/Engine.cpp b/src/engine/Engine.cpp
index 3db38f4..2a04b4d 100644
--- a/src/engine/Engine.cpp
+++ b/src/engine/Engine.cpp
@@ -44,6 +44,7 @@ void Engine::run() {
 
     // Demo: subscribe to a single tick and let the strategy react
     const std::string symbol = "BTCUSD";
+    /*
     broker_->subscribe_to_ticks(symbol, [&](const PriceData& pd){
         strategy_->on_price_tick(pd);
         auto act = strategy_->get_trade_action();
@@ -59,9 +60,10 @@ void Engine::run() {
             std::cout << "[Engine] No action.\n";
         }
     });
+    */
 
     std::cout << "[Engine] sleeping for like 12 seconds.\n";
-    std::this_thread::sleep_for(std::chrono::seconds(12));
+    std::this_thread::sleep_for(std::chrono::seconds(30));
     std::cout << "[Engine] Run complete.\n";
 }
 
diff --git a/src/main.cpp b/src/main.cpp
index 96351d8..588ddfa 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -14,17 +14,33 @@ int main() {
         std::cout << "debug is on! let's go\n";
     #endif
 
-    // 1. set up a broker to facilitate orders   
+    // 1. set up an exchange broker to facilitate orders
+    // The NullBroker is a dummy broker that will just do what you tell it.
     auto broker = std::make_unique<broker::NullBroker>();
 
     // 2. Set up one or more market-data adapters (per broker)
+    // These will provide market pricing data into the system on a tick-by-tick basis.
+    // Currently, BrokerMarketData just emits dummy ticks for demo purposes.
     auto feed1 = std::make_unique<adapter::BrokerMarketData>(*broker);
 
-    feed1->start(10);       // start the demo outputting a thing every second for 10 seconds
     // 3. provider (aggregator) that attaches feeds
     auto provider = std::make_unique<eng::ProviderMarketData>();
+    // Attach the feed before starting it so subscriptions are in place.
     provider->attach(std::move(feed1));
-    provider->subscribe_ticks({ "BTCUSD" }, [](const eng::Tick&){std::cout << "lol a tick\n";});
+
+    // Print full tick info when ticks arrive
+    provider->subscribe_ticks({ "BTCUSD" }, [](const eng::Tick& t){
+        auto tp = std::chrono::system_clock::to_time_t(t.ts);
+        std::cout << "Tick: " << t.symbol << " @ " << t.last << " time=" << std::ctime(&tp);
+    });
+
+    // start the feed (defaults to 30 seconds)
+    provider->start_all(30);
+    // note: ProviderMarketData::attach moved the unique_ptr into the provider, which
+    // will start the feed internally when engine runs or we could add an explicit start()
+    // For now, the concrete adapter was attached; if you want explicit start control,
+    // call start on the underlying feed after exposing it.
+    // For this demo we'll rely on Engine wiring which calls run() and keeps process alive.
     
 
     // provider->attach(std::move(feed2));
